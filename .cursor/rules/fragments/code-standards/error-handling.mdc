---
description: "Error handling patterns for React components, async operations, and user experience"
globs:
  - "**/*.ts"
  - "**/*.tsx"
---

# Error Handling Standards

## React Error Boundaries

```typescript
import {Component, type ErrorInfo, type ReactNode} from 'react';

type ErrorBoundaryProps = {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
};

type ErrorBoundaryState = {
  hasError: boolean;
  error?: Error;
};

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {hasError: false};
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {hasError: true, error};
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error Boundary caught:', error, errorInfo);
    this.props.onError?.(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <button onClick={() => this.setState({hasError: false})}>
            Try again
          </button>
        </div>
      );
    }
    return this.props.children;
  }
}
```

## Async Operation Hook

```typescript
const useAsyncOperation = <T, P extends any[] = []>(
  operation: (...args: P) => Promise<T>
) => {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [loading, setLoading] = useState(false);

  const execute = useCallback(async (...args: P) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await operation(...args);
      setData(result);
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [operation]);

  const reset = useCallback(() => {
    setData(null);
    setError(null);
    setLoading(false);
  }, []);

  return {data, error, loading, execute, reset};
};
```

## Service Layer Errors

```typescript
class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export const characterService = {
  async create(character: CreateCharacterRequest): Promise<Character> {
    try {
      const {data, error} = await supabase
        .from('characters')
        .insert(character)
        .select()
        .single();
      
      if (error) {
        throw new ApiError(
          `Failed to create character: ${error.message}`,
          400,
          error.code
        );
      }
      
      return data;
    } catch (err) {
      if (err instanceof ApiError) throw err;
      
      throw new ApiError(
        'Unexpected error while creating character',
        500,
        'UNKNOWN_ERROR'
      );
    }
  },
};
```

## Component Error Handling

```typescript
const DataComponent: React.FC<DataComponentProps> = ({userId}) => {
  const [errorState, setErrorState] = useState({
    hasError: false,
    error: undefined as Error | undefined,
    retryCount: 0,
  });
  
  const {data, error, loading, execute} = useAsyncOperation(
    () => characterService.getByUserId(userId)
  );

  useEffect(() => {
    if (error) {
      setErrorState(prev => ({
        hasError: true,
        error,
        retryCount: prev.retryCount + 1,
      }));
    }
  }, [error]);

  const handleRetry = useCallback(() => {
    setErrorState(prev => ({...prev, hasError: false, error: undefined}));
    execute();
  }, [execute]);

  if (errorState.hasError && errorState.error) {
    return (
      <div className="error-state">
        <h3>Failed to load data</h3>
        <div>{errorState.error.message}</div>
        {errorState.retryCount < 3 && (
          <button onClick={handleRetry}>
            Retry ({errorState.retryCount}/3)
          </button>
        )}
      </div>
    );
  }

  if (loading) return <LoadingSpinner />;

  return (
    <div>
      {data?.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
};
```

## User-Friendly Error Messages

```typescript
const getErrorMessage = (error: Error): string => {
  if (error instanceof ApiError) {
    switch (error.code) {
      case 'PGRST116': return 'Item not found.';
      case 'PGRST301': return 'Permission denied.';
      case '23505': return 'Item already exists.';
      case 'CONNECTION_ERROR': return 'Connection error. Check internet.';
      default: return 'Unexpected error. Please try again.';
    }
  }
  
  if (error.message.includes('fetch')) {
    return 'Network error. Check connection and try again.';
  }
  
  return 'Something went wrong. Please try again later.';
};
```

## Best Practices

- **Use Error Boundaries** to catch React component errors
- **Implement retry logic** with exponential backoff
- **Provide user-friendly messages** instead of technical details
- **Log errors with context** for debugging
- **Handle async operations** with proper loading/error states
- **Use structured error types** for consistent handling
- **Test error scenarios** to ensure graceful degradation
