---
description: 
globs: 
alwaysApply: true
---
# Learning-Focused Development

## Developer Context

The primary developer is a **frontend specialist** who wants to learn backend development through hands-on implementation. All backend work should be approached as a **learning opportunity** with comprehensive explanations and educational value.

## Teaching Approach for Backend Development

### Explanation-First Strategy
- **Explain before implementing**: Always explain the concept, pattern, or technology before writing code
- **Rationale for decisions**: Clearly state why we're choosing specific approaches
- **Alternative approaches**: Mention other options and why we're not using them
- **Learning objectives**: Explicitly state what the developer will learn from each task

### Supabase Learning Focus
Since we're using Supabase as our backend:

#### Database Concepts
- **Explain schema design**: Why we structure tables in specific ways
- **Relationship modeling**: How foreign keys and joins work
- **Indexing strategy**: When and why to add indexes
- **Data validation**: Database-level vs application-level validation

#### Authentication & Security
- **Row Level Security (RLS)**: How it works and why it's important
- **JWT tokens**: What they are and how Supabase handles them
- **Policy creation**: Step-by-step RLS policy explanations
- **Security best practices**: Common pitfalls and how to avoid them

#### API Patterns
- **RESTful design**: How Supabase auto-generates REST APIs
- **Query building**: Using the Supabase client effectively
- **Real-time subscriptions**: How they work under the hood
- **Error handling**: Backend error patterns and user experience

### Code Learning Patterns

#### Incremental Complexity
```typescript
// Start with simple, explicit code
const {data, error} = await supabase
  .from('characters')
  .select('*')
  .eq('user_id', userId);

// Explain each part:
// - supabase: our client instance
// - from('characters'): specify the table
// - select('*'): get all columns
// - eq('user_id', userId): filter by user ID
```

#### Progressive Enhancement
1. **Basic functionality first**: Get it working simply
2. **Add error handling**: Explain different error types
3. **Optimize performance**: Explain when and why
4. **Add advanced features**: Build on the foundation

### Educational Code Comments

#### Concept Explanations
```typescript
// Row Level Security (RLS) Policy:
// This ensures users can only see their own characters
// The policy is: (auth.uid() = user_id)
const {data: characters} = await supabase
  .from('characters')
  .select('*'); // RLS automatically filters by user_id
```

#### Decision Rationale
```typescript
// Using upsert instead of separate insert/update
// because we want to handle both new and existing records
// with a single operation (idempotent)
const {data, error} = await supabase
  .from('job_progress')
  .upsert({
    character_id, 
    job_type, 
    level 
  }, {
    onConflict: 'character_id,job_type' 
  });
```

#### Learning Checkpoints
```typescript
// Learning checkpoint: What did we just accomplish?
// 1. Created a database schema for character progress
// 2. Set up RLS to protect user data
// 3. Built a reusable service for job progress updates
// 4. Implemented optimistic updates for better UX
```

## Frontend-Backend Integration Learning

### API Design Teaching
- **Start with the frontend need**: "We need to update a job level"
- **Design the API interface**: What should the function signature look like?
- **Implement the backend**: How does Supabase handle this?
- **Connect the pieces**: How does data flow through the system?

### State Management Learning
- **Local state vs server state**: When to use each
- **Optimistic updates**: How and why they improve UX
- **Error recovery**: What happens when updates fail
- **Cache invalidation**: Keeping data fresh and consistent

### Performance Learning
- **Query optimization**: How to fetch data efficiently
- **Batching operations**: When and how to combine requests
- **Real-time updates**: When to use subscriptions vs polling
- **Pagination**: Handling large datasets

## Common Learning Scenarios

### Database Schema Design
When creating tables:
1. **Explain the domain**: What are we modeling?
2. **Identify relationships**: How do entities connect?
3. **Choose data types**: Why specific types for specific fields?
4. **Plan for growth**: How might this evolve?

### Security Implementation
When adding RLS policies:
1. **Identify the security requirement**: What are we protecting?
2. **Design the policy**: Who should access what?
3. **Implement step by step**: Break down complex policies
4. **Test the policy**: Verify it works as expected

### Performance Optimization
When optimizing queries:
1. **Identify the bottleneck**: What's slow and why?
2. **Explain the solution**: How does this improvement work?
3. **Measure the impact**: Show before/after performance
4. **Discuss trade-offs**: What did we gain/lose?

## Teaching Best Practices

### Scaffolding Approach
- **Start with working examples**: Show the pattern first
- **Explain the components**: Break down each part
- **Practice variations**: Apply the pattern to new scenarios
- **Build complexity**: Add features incrementally

### Error-Driven Learning
- **Embrace errors**: They're learning opportunities
- **Explain error messages**: What do they mean?
- **Debug together**: Walk through the problem-solving process
- **Prevent future errors**: Share common patterns and pitfalls

### Documentation Integration
- **Reference official docs**: Link to Supabase documentation
- **Explain the docs**: How to read and understand them
- **Fill gaps**: Provide context the docs might assume
- **Create shortcuts**: Build reusable patterns for common tasks

## Success Metrics for Learning

### Understanding Indicators
- Can explain **why** we chose specific approaches
- Can **predict** what will happen before running code
- Can **troubleshoot** issues independently
- Can **adapt** patterns to new requirements

### Practical Application
- Can **design** simple database schemas
- Can **write** basic RLS policies
- Can **optimize** common query patterns
- Can **integrate** backend changes with frontend code

### Confidence Building
- **Asks clarifying questions** about unfamiliar concepts
- **Suggests alternatives** when learning new patterns
- **Explains** backend concepts to validate understanding
- **Applies** learned patterns to new problems
